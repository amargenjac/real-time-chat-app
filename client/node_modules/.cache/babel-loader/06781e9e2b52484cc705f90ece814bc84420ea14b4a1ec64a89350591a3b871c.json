{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { reactive } from \"vue\";\nimport { io } from \"socket.io-client\";\nexport const state = reactive({\n  connected: false,\n  connectedUsers: [],\n  user: null,\n  UserChats: [{\n    chatId: null,\n    messages: []\n  }]\n});\n\n// \"undefined\" means the URL will be computed from the `window.location` object\nconst URL = \"http://localhost:8081\";\nexport const socket = io(URL);\nsocket.on('connect', () => {\n  state.connected = true;\n});\nsocket.on('users', users => {\n  users.forEach(user => {\n    state.user = user;\n  });\n  // put the current user first, and then sort by username\n  state.connectedUsers = users.sort((a, b) => {\n    if (a.self) return -1;\n    if (b.self) return 1;\n    if (a.username < b.username) return -1;\n    return a.username > b.username ? 1 : 0;\n  });\n});\nsocket.on('disconnect', () => {\n  state.connectedUsers.filter(user => user == state.user);\n});\nsocket.on('user connected', user => {\n  state.connectedUsers.forEach(element => {\n    if (user.username == element.username) return;\n  });\n  state.connectedUsers.push(user);\n});\nsocket.on('new message', (content, from, to) => {\n  let userChatIndex = state.UserChats.findIndex(userChat => userChat.chatId == to);\n  if (userChatIndex != -1) {\n    const message = {\n      content: content,\n      senderUsername: from\n    };\n    state.UserChats[userChatIndex].messages.push(message);\n  }\n});","map":{"version":3,"names":["reactive","io","state","connected","connectedUsers","user","UserChats","chatId","messages","URL","socket","on","users","forEach","sort","a","b","self","username","filter","element","push","content","from","to","userChatIndex","findIndex","userChat","message","senderUsername"],"sources":["C:/Users/amarg/real-time-chat-app/client/src/socket.js"],"sourcesContent":["import { reactive } from \"vue\";\r\nimport { io } from \"socket.io-client\";\r\n\r\nexport const state = reactive({\r\n    connected: false,\r\n    connectedUsers: [],\r\n    user: null,\r\n    UserChats: [{\r\n        chatId: null,\r\n        messages: []\r\n    }]\r\n});\r\n\r\n// \"undefined\" means the URL will be computed from the `window.location` object\r\nconst URL = \"http://localhost:8081\";\r\n\r\nexport const socket = io(URL);\r\n\r\nsocket.on('connect', () => {\r\n    state.connected = true;\r\n});\r\n\r\nsocket.on('users', (users) => {\r\n    users.forEach((user) => {\r\n        state.user = user\r\n    });\r\n    // put the current user first, and then sort by username\r\n    state.connectedUsers = users.sort((a, b) => {\r\n        if (a.self) return -1;\r\n        if (b.self) return 1;\r\n        if (a.username < b.username) return -1;\r\n        return a.username > b.username ? 1 : 0;\r\n    })\r\n})\r\n\r\nsocket.on('disconnect', () => {\r\n    state.connectedUsers.filter(user => user == state.user)\r\n})\r\n\r\nsocket.on('user connected', (user) => {\r\n    state.connectedUsers.forEach((element) => {\r\n        if (user.username == element.username) return;\r\n    }\r\n    );\r\n    state.connectedUsers.push(user);\r\n});\r\n\r\nsocket.on('new message', (content, from, to) => {\r\n    let userChatIndex = state.UserChats.findIndex(userChat => userChat.chatId == to)\r\n    if (userChatIndex != -1) {\r\n        const message = {\r\n            content: content,\r\n            senderUsername: from\r\n        }\r\n        state.UserChats[userChatIndex].messages.push(message)\r\n    }\r\n})"],"mappings":";AAAA,SAASA,QAAQ,QAAQ,KAAK;AAC9B,SAASC,EAAE,QAAQ,kBAAkB;AAErC,OAAO,MAAMC,KAAK,GAAGF,QAAQ,CAAC;EAC1BG,SAAS,EAAE,KAAK;EAChBC,cAAc,EAAE,EAAE;EAClBC,IAAI,EAAE,IAAI;EACVC,SAAS,EAAE,CAAC;IACRC,MAAM,EAAE,IAAI;IACZC,QAAQ,EAAE;EACd,CAAC;AACL,CAAC,CAAC;;AAEF;AACA,MAAMC,GAAG,GAAG,uBAAuB;AAEnC,OAAO,MAAMC,MAAM,GAAGT,EAAE,CAACQ,GAAG,CAAC;AAE7BC,MAAM,CAACC,EAAE,CAAC,SAAS,EAAE,MAAM;EACvBT,KAAK,CAACC,SAAS,GAAG,IAAI;AAC1B,CAAC,CAAC;AAEFO,MAAM,CAACC,EAAE,CAAC,OAAO,EAAGC,KAAK,IAAK;EAC1BA,KAAK,CAACC,OAAO,CAAER,IAAI,IAAK;IACpBH,KAAK,CAACG,IAAI,GAAGA,IAAI;EACrB,CAAC,CAAC;EACF;EACAH,KAAK,CAACE,cAAc,GAAGQ,KAAK,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IACxC,IAAID,CAAC,CAACE,IAAI,EAAE,OAAO,CAAC,CAAC;IACrB,IAAID,CAAC,CAACC,IAAI,EAAE,OAAO,CAAC;IACpB,IAAIF,CAAC,CAACG,QAAQ,GAAGF,CAAC,CAACE,QAAQ,EAAE,OAAO,CAAC,CAAC;IACtC,OAAOH,CAAC,CAACG,QAAQ,GAAGF,CAAC,CAACE,QAAQ,GAAG,CAAC,GAAG,CAAC;EAC1C,CAAC,CAAC;AACN,CAAC,CAAC;AAEFR,MAAM,CAACC,EAAE,CAAC,YAAY,EAAE,MAAM;EAC1BT,KAAK,CAACE,cAAc,CAACe,MAAM,CAACd,IAAI,IAAIA,IAAI,IAAIH,KAAK,CAACG,IAAI,CAAC;AAC3D,CAAC,CAAC;AAEFK,MAAM,CAACC,EAAE,CAAC,gBAAgB,EAAGN,IAAI,IAAK;EAClCH,KAAK,CAACE,cAAc,CAACS,OAAO,CAAEO,OAAO,IAAK;IACtC,IAAIf,IAAI,CAACa,QAAQ,IAAIE,OAAO,CAACF,QAAQ,EAAE;EAC3C,CACA,CAAC;EACDhB,KAAK,CAACE,cAAc,CAACiB,IAAI,CAAChB,IAAI,CAAC;AACnC,CAAC,CAAC;AAEFK,MAAM,CAACC,EAAE,CAAC,aAAa,EAAE,CAACW,OAAO,EAAEC,IAAI,EAAEC,EAAE,KAAK;EAC5C,IAAIC,aAAa,GAAGvB,KAAK,CAACI,SAAS,CAACoB,SAAS,CAACC,QAAQ,IAAIA,QAAQ,CAACpB,MAAM,IAAIiB,EAAE,CAAC;EAChF,IAAIC,aAAa,IAAI,CAAC,CAAC,EAAE;IACrB,MAAMG,OAAO,GAAG;MACZN,OAAO,EAAEA,OAAO;MAChBO,cAAc,EAAEN;IACpB,CAAC;IACDrB,KAAK,CAACI,SAAS,CAACmB,aAAa,CAAC,CAACjB,QAAQ,CAACa,IAAI,CAACO,OAAO,CAAC;EACzD;AACJ,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}